"""
Diagnostic aggregator configuration generator for hierarchical health monitoring
"""

import logging
from pathlib import Path
from typing import List, Dict, Optional
from ros2_build_tool_core.models import RobotProfile, HardwareComponent


class DiagnosticConfigGenerator:
    """
    Generate diagnostic aggregator configuration for system health monitoring

    Creates hierarchical analyzers that group diagnostics by component type:
    - /Sensors (lidar, cameras, IMU, GPS)
    - /Motors (wheel motors, joints)
    - /Controllers (Nav2, SLAM)
    - /System (CPU, memory, disk)
    """

    def __init__(self, package_path: Path, logger: logging.Logger):
        self.package_path = package_path
        self.config_dir = package_path / 'config'
        self.config_dir.mkdir(exist_ok=True)
        self.logger = logger

    def generate_diagnostic_config(
        self,
        profile: RobotProfile,
        hardware_components: List[HardwareComponent]
    ) -> Path:
        """
        Generate complete diagnostic aggregator configuration

        Returns: Path to generated config file
        """

        # Group hardware by type
        sensors = [hw for hw in hardware_components if hw.type in ['lidar', 'camera', 'imu', 'gps']]
        motors = [hw for hw in hardware_components if hw.type in ['motor', 'actuator', 'mobile_base']]
        odometry = [hw for hw in hardware_components if hw.type == 'odometry']

        config = """# Diagnostic Aggregator Configuration
# Auto-generated by ROS2 Build Tool

diagnostic_aggregator:
  ros__parameters:
    # Base path for aggregated diagnostics
    base_path: ""

    # Publish rate for aggregated diagnostics (Hz)
    pub_rate: 1.0

"""

        # Add analyzers for each component group
        analyzer_configs = []

        # Sensor analyzers
        if sensors:
            analyzer_configs.append(self._generate_sensor_analyzers(sensors))

        # Motor analyzers
        if motors:
            analyzer_configs.append(self._generate_motor_analyzers(motors))

        # Odometry analyzer
        if odometry:
            analyzer_configs.append(self._generate_odometry_analyzer())

        # Navigation analyzers
        if profile.navigation:
            analyzer_configs.append(self._generate_nav2_analyzers())

        # SLAM analyzers
        if profile.slam_type.value != 'none':
            analyzer_configs.append(self._generate_slam_analyzers(profile.slam_type.value))

        # System analyzers (always included)
        analyzer_configs.append(self._generate_system_analyzers())

        # Combine all analyzers
        config += "    analyzers:\n"
        for analyzer_config in analyzer_configs:
            config += analyzer_config

        # Write config file
        config_file = self.config_dir / 'diagnostics.yaml'
        with open(config_file, 'w') as f:
            f.write(config)

        self.logger.info(f"Generated diagnostic config: {config_file}")
        return config_file

    def _generate_sensor_analyzers(self, sensors: List[HardwareComponent]) -> str:
        """Generate analyzers for sensor components"""
        config = """      # Sensor Diagnostics
      sensors:
        type: "diagnostic_aggregator/AnalyzerGroup"
        path: "Sensors"
        analyzers:
"""

        # Group sensors by type
        sensor_types = {}
        for sensor in sensors:
            sensor_type = sensor.type
            if sensor_type not in sensor_types:
                sensor_types[sensor_type] = []
            sensor_types[sensor_type].append(sensor)

        # Create analyzer for each sensor type
        for sensor_type, sensor_list in sensor_types.items():
            type_name = sensor_type.capitalize()
            config += f"""          {sensor_type}:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "{type_name}"
            # Match diagnostics from {sensor_type} nodes
            contains: ["{sensor_type}"]
            regex: [".*{sensor_type}.*"]
            timeout: 5.0
"""

        return config

    def _generate_motor_analyzers(self, motors: List[HardwareComponent]) -> str:
        """Generate analyzers for motor/actuator components"""
        config = """      # Motor/Actuator Diagnostics
      motors:
        type: "diagnostic_aggregator/AnalyzerGroup"
        path: "Motors"
        analyzers:
          wheel_motors:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "Wheels"
            contains: ["wheel", "motor", "drive"]
            timeout: 5.0
"""

        return config

    def _generate_odometry_analyzer(self) -> str:
        """Generate analyzer for odometry"""
        return """      # Odometry Diagnostics
      odometry:
        type: "diagnostic_aggregator/GenericAnalyzer"
        path: "Odometry"
        contains: ["odom", "wheel"]
        timeout: 5.0
"""

    def _generate_nav2_analyzers(self) -> str:
        """Generate analyzers for Nav2 stack"""
        return """      # Navigation Stack Diagnostics
      navigation:
        type: "diagnostic_aggregator/AnalyzerGroup"
        path: "Navigation"
        analyzers:
          controller:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "Controller"
            contains: ["controller_server", "controller"]
            timeout: 5.0

          planner:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "Planner"
            contains: ["planner_server", "planner"]
            timeout: 5.0

          recoveries:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "Recoveries"
            contains: ["behavior_server", "recovery"]
            timeout: 5.0

          bt_navigator:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "BTNavigator"
            contains: ["bt_navigator"]
            timeout: 5.0
"""

    def _generate_slam_analyzers(self, slam_type: str) -> str:
        """Generate analyzers for SLAM"""
        return f"""      # SLAM Diagnostics
      slam:
        type: "diagnostic_aggregator/GenericAnalyzer"
        path: "SLAM"
        contains: ["{slam_type}", "slam", "map"]
        timeout: 5.0
"""

    def _generate_system_analyzers(self) -> str:
        """Generate analyzers for system resources"""
        return """      # System Resource Diagnostics
      system:
        type: "diagnostic_aggregator/AnalyzerGroup"
        path: "System"
        analyzers:
          cpu:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "CPU"
            contains: ["cpu", "processor"]
            timeout: 10.0

          memory:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "Memory"
            contains: ["memory", "ram"]
            timeout: 10.0

          disk:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "Disk"
            contains: ["disk", "storage"]
            timeout: 10.0

          network:
            type: "diagnostic_aggregator/GenericAnalyzer"
            path: "Network"
            contains: ["network", "wifi", "ethernet"]
            timeout: 10.0
"""

    def generate_diagnostic_launch(self, profile: RobotProfile) -> Path:
        """Generate launch file for diagnostic aggregator"""

        launch_content = f'''#!/usr/bin/env python3
"""
Diagnostic Aggregator Launch
Generated by ROS2 Build Tool
"""

from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare


def generate_launch_description():
    """Launch diagnostic aggregator with configuration"""

    use_sim_time = LaunchConfiguration('use_sim_time', default='false')

    pkg_share = FindPackageShare('{profile.name}_bringup')
    config_file = PathJoinSubstitution([pkg_share, 'config', 'diagnostics.yaml'])

    diagnostic_aggregator = Node(
        package='diagnostic_aggregator',
        executable='aggregator_node',
        name='diagnostic_aggregator',
        output='screen',
        parameters=[
            config_file,
            {{'use_sim_time': use_sim_time}}
        ]
    )

    return LaunchDescription([
        diagnostic_aggregator
    ])
'''

        launch_dir = self.package_path / 'launch'
        launch_dir.mkdir(exist_ok=True)

        launch_file = launch_dir / 'diagnostics.launch.py'
        with open(launch_file, 'w') as f:
            f.write(launch_content)

        launch_file.chmod(0o755)
        self.logger.info(f"Generated diagnostic launch file: {launch_file}")

        return launch_file

    def generate_health_monitor_config(self) -> str:
        """
        Generate configuration for custom health monitoring thresholds

        Returns: YAML string with health thresholds
        """
        return """# Health Monitoring Thresholds
# These thresholds determine when to raise warnings/errors

health_monitor:
  ros__parameters:
    # Topic rate monitoring (Hz)
    topic_rates:
      /scan:
        min: 5.0
        max: 15.0
        warn_below: 8.0

      /odom:
        min: 20.0
        max: 100.0
        warn_below: 30.0

      /imu:
        min: 50.0
        max: 200.0
        warn_below: 80.0

    # Transform rate monitoring (Hz)
    transform_rates:
      odom_to_base_link:
        min: 20.0
        warn_below: 30.0

      map_to_odom:
        min: 1.0
        warn_below: 5.0

    # System resource thresholds
    system_resources:
      cpu_percent:
        warn_above: 80.0
        error_above: 95.0

      memory_percent:
        warn_above: 85.0
        error_above: 95.0

      disk_percent:
        warn_above: 90.0
        error_above: 98.0

    # Timeout thresholds (seconds)
    timeouts:
      sensor_data: 5.0
      controller_feedback: 2.0
      localization: 5.0
"""